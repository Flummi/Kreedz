#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <cstrike>
#include <fakemeta>
#include <hamsandwich>

#include <AmxxArch>
#include <curl>


//#define COUNTRY_FLAGS     // if you use server version uncomment this line
#define PLUGIN 		"KZ_WRBOT"
#define VERSION 	"1.0"
#define AUTHOR 		"Destroman Edited"

//#define DEV_DEBUG


new g_szMapName[32];

new Array:fPlayerAngle, Array:fPlayerKeys, Array:fPlayerVelo, Array:fPlayerOrigin;
new g_timer;
new Float:timer_time[33], bool:timer_started[33], bool:IsPaused[33], Float:g_pausetime[33], bool:bot_finish_use[33];
new g_bot_start, g_bot_enable, g_bot_frame, wr_bot_id;
new SyncHudTimer, SyncHudBotTimer
new Trie:g_tButtons[2];
new g_Bot_Icon_ent, url_sprite[64], url_sprite_xz[64];
new WR_TIME[130], WR_NAME[130]
new Float:nExttHink = 0.009
new local_demo_folder[128]

new country_flag, delete_local_files;
new hud_message, timer_bot, timer_option, cooldown_startbot, update_timer, g_xc, g_yc, g_start_frame;


#define SetBhopBlocks(%1,%2)   %1[%2>>5] |=  1<<(%2 & 31)
#define GetBhopBlocks(%1,%2)   %1[%2>>5] &   1<<(%2 & 31)
new g_bBlocks[64]

#define NUM_THREADS 256

#pragma dynamic 32767 // Without this line will crash server!!

#define PEV_PDATA_SAFE    2

#define OFFSET_TEAM            114
#define OFFSET_DEFUSE_PLANT    193
#define HAS_DEFUSE_KIT        (1<<16)
#define OFFSET_INTERNALMODEL    126

new bool:g_Demos = false;

new iXJWRs, iCCWRs, iArchive;
new bool:bFoundDemo = false;
new iDemo_header_size;
new iArchiveName[256];
new iDemoName[256];
new iNavName[256];
new iFile;
new iParsedFile;


public plugin_precache()
{
	get_mapname(g_szMapName, sizeof(g_szMapName) - 1);
	strtolower(g_szMapName);
	#if defined COUNTRY_FLAGS
	parsing_country("xj");
	#endif
	
	new i;
	for(i = 0; i < sizeof(g_tButtons); i++)
		g_tButtons[i] = TrieCreate();

	new szStartTargets[][] = {
	"counter_start", "clockstartbutton", "firsttimerelay", "but_start",
	"counter_start_button", "multi_start", "timer_startbutton", "start_timer_emi", "gogogo"
	};

	for(i = 0; i < sizeof szStartTargets ; i++)
		TrieSetCell(g_tButtons[0], szStartTargets[i], i);

	new szFinishTargets[][] = {
	"counter_off", "clockstopbutton", "clockstop", "but_stop",
	"counter_stop_button", "multi_stop", "stop_counter", "m_counter_end_emi"
	};

	for (i = 0; i < sizeof szFinishTargets; i++)
		TrieSetCell(g_tButtons[1], szFinishTargets[i], i);

	new Ent = engfunc( EngFunc_CreateNamedEntity , engfunc( EngFunc_AllocString,"info_target" ) );
	set_pev(Ent, pev_classname, "BotThink");
	set_pev(Ent, pev_nextthink, get_gametime() + 0.01 );
	register_forward( FM_Think, "fwd_Think", 1 );
	fPlayerAngle  = ArrayCreate( 2 );
	fPlayerOrigin = ArrayCreate( 3 );
	fPlayerVelo   = ArrayCreate( 3 );
	fPlayerKeys   = ArrayCreate( 1 );
}

public plugin_init ()
{
	register_plugin( PLUGIN, VERSION, AUTHOR);

	hud_message = register_cvar("hud_message","1");
	timer_bot = register_cvar("timer_bot","1");
	timer_option = register_cvar("timer_option","1");
	cooldown_startbot = register_cvar("cooldown_startbot","5");
	update_timer = register_cvar("update_timer","1");
	g_xc = register_cvar("x_coordinates","-1.0");
	g_yc = register_cvar("y_coordinates","0.35");
	g_start_frame = register_cvar("delete_frame","0");
	country_flag = register_cvar("country_flag","1");
	delete_local_files = register_cvar("delete_local_files","1");
	//nvault запуск
	set_task( 2.0, "announce");

	RegisterHam(Ham_TakeDamage, "player", "BotAfterDamage", 0)
	register_concmd("amx_wrbotmenu", "ClCmd_ReplayMenu");
	new kreedz_cfg[128], ConfigDir[64]
	get_configsdir(ConfigDir, 64)
	formatex(kreedz_cfg,128,"%s/wrbot.cfg", ConfigDir)

	new szConfigDir[128], szSqlCfg[128];
	get_configsdir(szConfigDir, charsmax(szConfigDir));
	formatex(szSqlCfg, charsmax(szSqlCfg), "%s/sql.cfg", szConfigDir);

	if(file_exists(szSqlCfg))
	{
		server_cmd("exec %s", szSqlCfg);
		server_exec();
	}
	else
	{
		server_print("[Error] sql.cfg doesn't exists.");
	}

	if(get_pcvar_num(country_flag))
		register_forward(FM_AddToFullPack, "addToFullPack", 1)

	if(get_pcvar_num(timer_bot) == 1)
	{
		if(get_pcvar_num(update_timer) == 1)
		{
			new iTimer = create_entity("info_target")
			entity_set_float(iTimer, EV_FL_nextthink, get_gametime() + 0.08)
			entity_set_string(iTimer, EV_SZ_classname, "hud_update")
			register_think("hud_update", "timer_task")
		}
		else if(get_pcvar_num(update_timer) == 2)
		{
			set_task(0.1,"timer_task",0,_,_,"b")
		}
		else if(get_pcvar_num(update_timer) == 3)
		{
			new iTimerEnt = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString , "info_target"))
			set_pev(iTimerEnt, pev_classname, "kz_time_think")
			set_pev(iTimerEnt, pev_nextthink, get_gametime() + 1.0)
		}
	}

	SyncHudTimer = CreateHudSyncObj()
	SyncHudBotTimer = CreateHudSyncObj()
}

new archive_dir[128] = "addons/amxmodx/data/kz_downloader/archives";
new temp_dir[128] = "addons/amxmodx/data/kz_downloader/temp";

public plugin_cfg()
{
	if(!dir_exists("addons/amxmodx/data/kz_downloader"))
		mkdir("addons/amxmodx/data/kz_downloader")
		new datadir[128];
		
	if(!dir_exists(archive_dir))
		mkdir(archive_dir);
	if(!dir_exists(temp_dir))
		mkdir(temp_dir);
		
	get_localinfo( "amxx_datadir", datadir, charsmax( datadir ) );
	format( local_demo_folder, sizeof(local_demo_folder), "%s/kz_wrbot", datadir );
	
	if(get_pcvar_num(delete_local_files)){
		check_dir();
	}
	if(!dir_exists(local_demo_folder))
	{
		mkdir(local_demo_folder);
	}
	SetTouch();
}

public BotAfterDamage ( victim, weapon, attacker, Float:damage, damagebits )
{
	if (is_user_bot(victim) || is_user_bot(attacker))
		if ( damagebits & DMG_FALL )
			set_pev(wr_bot_id,pev_health,9999.0)
	else
		return HAM_SUPERCEDE

	return HAM_IGNORED
}

public Ham_ButtonUse( id )
{
	new Float:origin[3];
	pev( id, pev_origin, origin );
	new ent = -1;
	while ( (ent = find_ent_in_sphere( ent, origin, 100.0 ) ) != 0 )
	{
		new classname[32];
		pev( ent, pev_classname, classname, charsmax( classname ) );

			new Float:eorigin[3];
			get_brush_entity_origin( ent, eorigin );
			static Float:Distance[2];
			new szTarget[32];
			pev( ent, pev_target, szTarget, 31 );

			if ( TrieKeyExists( g_tButtons[0], szTarget ) )
			{
				if( !g_bot_start && get_pcvar_num(g_start_frame) != 0)
					g_bot_start = g_bot_frame - get_pcvar_num(g_start_frame);

				if( g_bot_start < 0 )
					g_bot_start = 0;

				if ( vector_distance( origin, eorigin ) >= Distance[0] )
				{
					timer_time[id] = get_gametime()
					IsPaused[id] = false
					timer_started[id] = true
					bot_finish_use[id] = false;
				}
				Distance[0] = vector_distance( origin, eorigin );
			}
			if ( TrieKeyExists( g_tButtons[1], szTarget ) )
			{
				if ( vector_distance( origin, eorigin ) >= Distance[1] )
				{
					if (!bot_finish_use[id])
					{
						if(timer_started[id])
						{
							if(get_pcvar_num(cooldown_startbot) == 0)
								Start_Bot();
							else
								StartCountDown();
						}
						timer_started[id] = false;
						bot_finish_use[id] = true;
					}
				}
				Distance[1] = vector_distance( origin, eorigin );
			}
	}
}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TIMER ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
public timer_task(iTimer)
{
	new Dead[32], deadPlayers
	get_players(Dead, deadPlayers, "bh")
	for(new i=0;i<deadPlayers;i++)
	{
		new specmode = pev(Dead[i], pev_iuser1)
		if(specmode == 2 || specmode == 4)
		{
			new target = pev(Dead[i], pev_iuser2)
			if(is_user_alive(target))
			{
				if (timer_started[target] && target == wr_bot_id)
				{
					new Float:kreedztime = get_gametime() - (IsPaused[target] ? get_gametime() - g_pausetime[target] : timer_time[target])
					new imin = floatround( kreedztime / 60.0, floatround_floor );
					new isec = floatround( kreedztime - imin * 60, floatround_floor );
					new mili = floatround( ( kreedztime - ( imin * 60 + isec ) ) * 100, floatround_floor );
					if(get_pcvar_num(timer_option) == 1)
					{
						client_print(Dead[i], print_center , "[ %02i:%02i.%02i ]",imin, isec, mili, IsPaused[target] ? "| *Paused*" : "")
					}
					else if(get_pcvar_num(timer_option) == 2)
					{
						set_hudmessage(255, 255, 255, get_pcvar_float(g_xc), get_pcvar_float(g_yc), 0, 0.0, 1.0, 0.0, 0.0)
						ShowSyncHudMsg(Dead[i], SyncHudBotTimer, "[ %02i:%02i.%02i ]",imin, isec, mili, IsPaused[target] ? "| *Paused*" : "")
					}
				}
				else if (!timer_started[target] && target == wr_bot_id)
				{
					client_print(Dead[i], print_center, "")
				}
			}
		}
	}

	if(get_pcvar_num(update_timer) == 1) entity_set_float(iTimer, EV_FL_nextthink, get_gametime() + 0.07)
}

public Pause()
{
	if(!IsPaused[wr_bot_id])
	{
		g_pausetime[wr_bot_id] = get_gametime() - timer_time[wr_bot_id]
		timer_time[wr_bot_id] = 0.0
		IsPaused[wr_bot_id] = true
		g_bot_enable = 2;
	}
	else
	{
		if(timer_started[wr_bot_id])
		{
			timer_time[wr_bot_id] = get_gametime() - g_pausetime[wr_bot_id]
		}
		IsPaused[wr_bot_id] = false
		g_bot_enable = 1;
	}
}

public fwd_Think( iEnt )
{
	if ( !pev_valid( iEnt ) )
		return(FMRES_IGNORED);

	static className[32];
	pev( iEnt, pev_classname, className, 31 );

	if ( equal( className, "DemThink" ) )
	{
		static bool:Finished;
		for(new i = 0; i < NUM_THREADS; i++)
		{
			if(ReadFrames(iFile))
			{
				Finished = true;
				break;
			}
		}

		if(Finished)
		{
			set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_KILLME)
			fclose( iFile );
			LoadParsedInfo( iNavName );
		}
		else
		{
			set_pev( iEnt, pev_nextthink, get_gametime() + 0.001 )
		}
	}
	if ( equal( className, "NavThink" ) )
	{
		static bool:Finished;
		for(new i = 0; i < NUM_THREADS; i++)
		{
			if(!ReadParsed(iEnt))
			{
				Finished = true;
				break;
			}
		}

		if(Finished)
		{
			set_pev(iEnt, pev_flags, pev(iEnt, pev_flags) | FL_KILLME)
			fclose( iFile );
			//delete_file(iNavName);
			set_task( 2.0, "StartCountDown");
		}
	}


	if(equal(className, "kz_time_think"))
	{
		timer_task(1)
		set_pev(iEnt, pev_nextthink, get_gametime() + 0.08)
	}

	if ( equal( className, "BotThink" ) )
	{
		BotThink( wr_bot_id );
		set_pev( iEnt, pev_nextthink, get_gametime() + nExttHink );
	}

	return(FMRES_IGNORED);
}

public BotThink( id )
{
	static Float:ViewOrigin[3], Float:ViewAngle[3], Float:ViewVelocity[3], ViewKeys;

	static Float:last_check, Float:game_time, nFrame;
	game_time = get_gametime();

	if( game_time - last_check > 1.0 )
	{
		if (nFrame < 100)
			nExttHink = nExttHink - 0.0001
		else if (nFrame > 100)
			nExttHink = nExttHink + 0.0001

		nFrame = 0;
		last_check = game_time;
	}

	if(g_bot_enable == 1 && wr_bot_id)
	{
		g_bot_frame++;
		if ( g_bot_frame < ArraySize( fPlayerAngle ) )
		{
			ArrayGetArray( fPlayerOrigin, g_bot_frame, ViewOrigin );
			ArrayGetArray( fPlayerAngle, g_bot_frame, ViewAngle );
			ArrayGetArray( fPlayerVelo, g_bot_frame, ViewVelocity)
			ViewKeys = ArrayGetCell( fPlayerKeys, g_bot_frame );

			if(ViewKeys&IN_ALT1) ViewKeys|=IN_JUMP;
			if(ViewKeys&IN_RUN)  ViewKeys|=IN_DUCK;

			if(ViewKeys&IN_RIGHT)
			{
				engclient_cmd(id, "weapon_usp");
				ViewKeys&=~IN_RIGHT;
			}
			if(ViewKeys&IN_LEFT)
			{
				engclient_cmd(id, "weapon_knife");
				ViewKeys&=~IN_LEFT;
			}
			if ( ViewKeys & IN_USE )
			{
				Ham_ButtonUse( id );
				ViewKeys &= ~IN_USE;
			}

			engfunc(EngFunc_RunPlayerMove, id, ViewAngle, ViewVelocity[0], ViewVelocity[1], 0.0, ViewKeys, 0, 10);
			set_pev( id, pev_v_angle, ViewAngle );
			ViewAngle[0] /= -3.0;
			set_pev(id, pev_velocity, ViewVelocity);
			set_pev(id, pev_angles, ViewAngle);
			set_pev(id, pev_origin, ViewOrigin);
			set_pev(id, pev_button, ViewKeys );

			if( pev( id, pev_gaitsequence ) == 4 && ~pev( id, pev_flags ) & FL_ONGROUND )
				set_pev( id, pev_gaitsequence, 6 );

			if(nFrame == ArraySize( fPlayerAngle ) - 1)
			{
				if(get_pcvar_num(cooldown_startbot) == 0)
					Start_Bot();
				else
					StartCountDown();
			}

		} else  {
			g_bot_frame = 0;
		}
	}
	nFrame++;
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SETTING MENU ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

public ClCmd_ReplayMenu(id)
{
	if(!access(id,ADMIN_MENU))
		return PLUGIN_HANDLED;

	new title[512]
	formatex(title, 500, "\wSetting Bot Replay Menu^nName: \y%s\w^nRecord: \y%s", WR_NAME, WR_TIME)
	new menu = menu_create(title, "ReplayMenu_Handler")
	menu_additem(menu, "Start/Reset", "1");

	if(get_pcvar_num(timer_bot))
	{
		if (g_bot_enable == 1)
		   menu_additem(menu, "Pause^n", "2");
		else
			menu_additem(menu, "Play^n", "2");
	}
	else
	{
		menu_additem(menu, "\dPause - disabled ^n", "2");
	}
	menu_additem(menu, "Kick bot", "3");
	menu_display(id, menu, 0);

	return PLUGIN_HANDLED
}

public ReplayMenu_Handler(id, menu, item)
{
	if(item == MENU_EXIT)
		return PLUGIN_HANDLED;

	switch(item)
	{
		case 0:
		{
			if(!wr_bot_id)
				StartCountDown()
			else
				Start_Bot()
		}
		case 1: if(get_pcvar_num(timer_bot)) Pause();
		case 2:
		{
			if(wr_bot_id)
				server_cmd("kick #%d", get_user_userid(wr_bot_id))
		}
	}
	ClCmd_ReplayMenu(id);
	return PLUGIN_HANDLED;
}

Create_Bot()
{
	if (file_exists(iDemoName))	delete_file(iDemoName);
	new txt[64]
	formatex(txt, charsmax(txt), "[WR] %s %s", WR_NAME, WR_TIME);
	new id = engfunc(EngFunc_CreateFakeClient, txt);
	if(pev_valid(id))
	{
		set_user_info(id, "rate", "10000");
		set_user_info(id, "cl_updaterate", "60");
		set_user_info(id, "cl_cmdrate", "60");
		set_user_info(id, "cl_lw", "1");
		set_user_info(id, "cl_lc", "1");
		set_user_info(id, "cl_dlmax", "128");
		set_user_info(id, "cl_righthand", "1");
		set_user_info(id, "_vgui_menus", "0");
		set_user_info(id, "_ah", "0");
		set_user_info(id, "dm", "0");
		set_user_info(id, "tracker", "0");
		set_user_info(id, "friends", "0");
		set_user_info(id, "*bot", "1");
		set_pev(id, pev_flags, pev(id, pev_flags) | FL_FAKECLIENT);
		set_pev(id, pev_colormap, id);

		dllfunc(DLLFunc_ClientConnect, id, "WR BOT", "127.0.0.1");
		dllfunc(DLLFunc_ClientPutInServer, id);

		cs_set_user_team(id, CS_TEAM_CT);
		cs_set_user_model(id, "sas");

		ham_give_weapon(id,"weapon_knife")
		ham_give_weapon(id,"weapon_usp")
		cs_set_user_bpammo(id, CSW_USP, 250)

		if(get_pcvar_num(country_flag)) create_bot_icon(id)

		if(!is_user_alive(id)) dllfunc(DLLFunc_Spawn, id);

		return id;
	}
	return 0;
}

//Начало отсчета
public StartCountDown()
{
	if(!wr_bot_id)
		wr_bot_id = Create_Bot();

	g_timer = get_pcvar_num(cooldown_startbot);
	set_task(1.0, "Show");
}

public Show()
{
	g_timer--;
	set_hudmessage(255, 255, 255, 0.05, 0.2, 0, 6.0, 1.0)

	if(g_timer && g_timer >= 0)
	{
		if(get_pcvar_num(hud_message)) ShowSyncHudMsg(0, SyncHudTimer, "WR bot starts run in: %i sec", g_timer);
		set_task(1.0, "Show");
	}
	else {
		if(get_pcvar_num(hud_message)) ShowSyncHudMsg(0, SyncHudTimer, "Bot has started");
		g_bot_enable = 1;
		Start_Bot()
	}
}

Start_Bot()
{
	g_bot_frame = g_bot_start;
	timer_started[wr_bot_id] = false
}

public client_disconnect( id )
{
	if( id == wr_bot_id )
	{
		timer_time[id] = 0.0
		IsPaused[wr_bot_id] = false
		timer_started[wr_bot_id] = false
		g_bot_enable = 0;
		g_bot_frame = 0;
		wr_bot_id = 0;
		destroy_bot_icon()
	}
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Icon Bot ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

public create_bot_icon(id)
{
	g_Bot_Icon_ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "env_sprite"))

		if(file_exists(url_sprite))
			engfunc(EngFunc_SetModel, g_Bot_Icon_ent, url_sprite)
		else if(file_exists(url_sprite_xz))
			engfunc(EngFunc_SetModel, g_Bot_Icon_ent, url_sprite_xz)
		else
			return

	set_pev(g_Bot_Icon_ent, pev_solid, SOLID_NOT)
	set_pev(g_Bot_Icon_ent, pev_movetype, MOVETYPE_FLYMISSILE)
	set_pev(g_Bot_Icon_ent, pev_iuser2, id)
	set_pev(g_Bot_Icon_ent, pev_scale, 0.25)
}

destroy_bot_icon()
{
	if(g_Bot_Icon_ent)
		engfunc(EngFunc_RemoveEntity, g_Bot_Icon_ent)

	g_Bot_Icon_ent = 0
}

public addToFullPack(es, e, ent, host, hostflags, player, pSet)
{
	if(wr_bot_id == host)
	{
		return FMRES_IGNORED;
	}

	if(wr_bot_id)
	{
		if(pev_valid(ent) && (pev(ent, pev_iuser1) == pev(ent, pev_owner)))
		{
			new user = pev(ent, pev_iuser2)
			new specmode = pev(host, pev_iuser1)

			if(is_user_alive(user))
			{
				new Float: playerOrigin[3]
				pev(user, pev_origin, playerOrigin)
				playerOrigin[2] += 42
				engfunc(EngFunc_SetOrigin, ent, playerOrigin)

				if(specmode == 4)
				{
					set_es(es, ES_Effects, EF_NODRAW)
				}
			}
		}
	}

	return FMRES_IGNORED;
}

public BhopTouch(iBlock, id)
{
	if(GetBhopBlocks(g_bBlocks, iBlock))
		if(is_user_bot(id))
			return HAM_SUPERCEDE;

	return PLUGIN_CONTINUE;
}

SetTouch()
{
	RegisterHam(Ham_Touch, "func_door", "BhopTouch");

	new iDoor = FM_NULLENT;
	while((iDoor = find_ent_by_class( iDoor, "func_door")))
		SetBhopBlocks(g_bBlocks, iDoor);
}






enum _:Consts
{
	HEADER_SIZE         = 544,
	HEADER_SIGNATURE_CHECK_SIZE = 6,
	HEADER_SIGNATURE_SIZE       = 8,
	HEADER_MAPNAME_SIZE     = 260,
	HEADER_GAMEDIR_SIZE     = 260,

	MIN_DIR_ENTRY_COUNT     = 1,
	MAX_DIR_ENTRY_COUNT     = 1024,
	DIR_ENTRY_SIZE          = 92,
	DIR_ENTRY_DESCRIPTION_SIZE  = 64,

	MIN_FRAME_SIZE          = 12,
	FRAME_CONSOLE_COMMAND_SIZE  = 64,
	FRAME_CLIENT_DATA_SIZE      = 32,
	FRAME_EVENT_SIZE        = 84,
	FRAME_WEAPON_ANIM_SIZE      = 8,
	FRAME_SOUND_SIZE_1      = 8,
	FRAME_SOUND_SIZE_2      = 16,
	FRAME_DEMO_BUFFER_SIZE      = 4,
	FRAME_NETMSG_SIZE       = 468,
	FRAME_NETMSG_DEMOINFO_SIZE  = 436,
	FRAME_NETMSG_MOVEVARS_SIZE  = 32,
	FRAME_NETMSG_MIN_MESSAGE_LENGTH = 0,
	FRAME_NETMSG_MAX_MESSAGE_LENGTH = 65536
};

enum DemoHeader {
	netProtocol,
	demoProtocol,
	mapName[HEADER_MAPNAME_SIZE],
	gameDir[HEADER_GAMEDIR_SIZE],
	mapCRC,
	directoryOffset
};

enum DemoEntry {
	dirEntryCount,
	type,
	description[DIR_ENTRY_DESCRIPTION_SIZE],
	flags,
	CDTrack,
	trackTime,
	frameCount,
	offset,
	fileLength,
	frames,
	ubuttons /* INT 16 */
};

enum FrameHeader
{
	Type,
	Float:Timestamp,
	Number
}


enum NetMsgFrame {
	Float:timestamp,
	Float:view[3],
	viewmodel
}

new iDemoEntry[DemoEntry];
new iDemoHeader[DemoHeader];
new iDemoFrame[FrameHeader];

public announce()
{
	new CURL:curl = curl_easy_init();
	if(curl)
	{
		new filename[128];
		format( filename, charsmax( filename ), "%s/demos.txt", archive_dir );
		delete_file(filename);
		iXJWRs = fopen(filename, "wb");
		curl_easy_setopt(curl, CURLOPT_URL, "https://xtreme-jumps.eu/demos.txt");
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, "write_xj");
		curl_easy_perform(curl, "complete_xj")
	}
}

public write_xj(data[], size, nmemb) {
	new real_size = size*nmemb

	for(new i = 0; i < nmemb; i++)
	{
		if(i < nmemb)
		fwrite(iXJWRs, data[i], BLOCK_BYTE);
	}

	return real_size

}

public complete_xj(CURL:curl, CURLcode:code) {
	curl_easy_cleanup(curl)
	fclose(iXJWRs);
	new CURL:curl = curl_easy_init();
	if(curl)
	{
		new filename[128];
		format( filename, charsmax( filename ), "%s/demoz.txt", archive_dir );
		delete_file(filename);
		iCCWRs = fopen(filename, "wb");
		curl_easy_setopt(curl, CURLOPT_URL, "https://cosy-climbing.net/demoz.txt");
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, "write_cc");
		curl_easy_perform(curl, "complete_cc")
	}
}

public write_cc(data[], size, nmemb) {
	new real_size = size*nmemb

	for(new i = 0; i < nmemb; i++)
	{
		if(i < nmemb)
		fwrite(iCCWRs, data[i], BLOCK_BYTE);
	}

	return real_size

}

public complete_cc(CURL:curl, CURLcode:code) {
	curl_easy_cleanup(curl)
	fclose(iCCWRs);

	OnDemosComplete(0);
}

public OnDemosComplete( Index )
{
		new demoslist[128];
		format( demoslist, charsmax( demoslist ), "%s/demos.txt", archive_dir );
		#if defined DEV_DEBUG
		server_print( "Parsing XJ Demo List" );
		#endif
		new iDemosList  = fopen( demoslist, "rb" );
		new ExplodedString[7][128];
		new Line[128];
		new MapName[64];
		get_mapname( MapName, 63 );
//		server_print("MapName = %s", MapName)
		while ( !feof( iDemosList ) )
		{
			fgets( iDemosList, Line, charsmax( Line ) );
			ExplodeString( ExplodedString, 6, 127, Line, ' ' );
			new parsedmap[128];
			parsedmap = ExplodedString[0];
			format( parsedmap, charsmax( parsedmap ), "%s ", parsedmap );
			if ( containi( parsedmap, MapName ) == 0 )
			{
				bFoundDemo = true;
				break;
			}
		}
		
		if ( !bFoundDemo )
		{
			get_mapname( MapName, 63 );
			format( MapName, charsmax( MapName ), "%s[", MapName );
			fseek( iDemosList, 0, SEEK_SET );
			while ( !feof( iDemosList ) )
			{
				fgets( iDemosList, Line, charsmax( Line ) );
				ExplodeString( ExplodedString, 6, 127, Line, ' ' );
					new found = containi( ExplodedString[0], MapName );
					if ( found == 0 )
					{
//						server_print("found = %s", found);
						new len = strlen(MapName);
						ExplodedString[0][len] = 0;
						bFoundDemo = true;
						break;
					}
			}
		}
		if(bFoundDemo)
		{
			new Float:Date = str_to_float( ExplodedString[1] );
			new sWRTime[24];
			fnConvertTime( Date, sWRTime, charsmax( sWRTime ) );
			format( iArchiveName, charsmax( iArchiveName ), "%s_%s_%s", ExplodedString[0], ExplodedString[2], sWRTime );
			
			format( iNavName, sizeof(iNavName), "%s/%s.nav", local_demo_folder, iArchiveName );
			StringTimer(Date, WR_TIME, sizeof(WR_TIME) - 1);
			WR_NAME = ExplodedString[2];
				
			if(file_exists(iNavName)) 
			{
				LoadParsedInfo( iNavName );
			}
			else if (str_to_float(ExplodedString[1]) != 0)
			{
				new iLink[512];
				format( iLink, charsmax( iLink ), "http://files.xtreme-jumps.eu/demos/%s.rar", iArchiveName );
				server_print("download link = %s", iLink);
				DownloadDemoArchive(iArchiveName, iLink);
			}
			else {
				server_print("*No WR on this map");
			}
		}
		else
		{
			CheckCCList();
		}
}

public CheckCCList()
{
	new demoslist[128];
	format( demoslist, charsmax( demoslist ), "%s/demoz.txt", archive_dir );
	#if defined DEV_DEBUG
	server_print( "Parsing Cosy Demo List" );
	#endif
	new iDemosList  = fopen( demoslist, "rb" );
	new ExplodedString[7][128];
	new Line[128];
	new MapName[64];
	get_mapname( MapName, 63 );
	while ( !feof( iDemosList ) )
	{
		fgets( iDemosList, Line, charsmax( Line ) );
		ExplodeString( ExplodedString, 6, 127, Line, ' ' );
		new parsedmap[128];
		parsedmap = ExplodedString[0];
		format( parsedmap, charsmax( parsedmap ), "%s ", parsedmap );
		if ( containi( parsedmap, MapName ) == 0 )
		{
			bFoundDemo = true;
			break;
		}
	}
	if ( !bFoundDemo )
	{
		get_mapname( MapName, 63 );
		format( MapName, charsmax( MapName ), "%s[", MapName );
		fseek( iDemosList, 0, SEEK_SET );
		while ( !feof( iDemosList ) )
		{
			fgets( iDemosList, Line, charsmax( Line ) );
			ExplodeString( ExplodedString, 6, 127, Line, ' ' );
			new found = containi( ExplodedString[0], MapName );
			if ( found == 0 )
			{
				new len = strlen(MapName);
				ExplodedString[0][len] = 0;
//				server_print("found = %s", found);
				bFoundDemo = true;
				break;
			}
		}
	}
	if(bFoundDemo)
	{
	
		new Float:Date = str_to_float( ExplodedString[1] );
		new sWRTime[24];
		fnConvertTime( Date, sWRTime, charsmax( sWRTime ) );
		// format( iArchiveName, charsmax( iArchiveName ), "%s_%s_%s", ExplodedString[0], ExplodedString[2], sWRTime );
		format( iArchiveName, charsmax( iArchiveName ), "%s_%s_%s", g_szMapName, ExplodedString[2], sWRTime );
		format( iNavName, sizeof(iNavName), "%s/%s.nav", local_demo_folder, iArchiveName );
		StringTimer(Date, WR_TIME, sizeof(WR_TIME) - 1);
		WR_NAME = ExplodedString[2];
	
		if(file_exists(iNavName)) {
			
			LoadParsedInfo( iNavName );
		}
		else if (str_to_float(ExplodedString[1]) != 0)
		{
			new iLink[512];
			format( iLink, charsmax( iLink ), "https://cosy-climbing.net/files/demos/%s.rar", iArchiveName );
			server_print("download link = %s", iLink);
			DownloadDemoArchive(iArchiveName, iLink);
		}
		else {
			server_print("*No WR on this map");
		}		
		
	}
}


public DownloadDemoArchive(iArchiveName[], iLink[])
{
	new filename[128];
	format( filename, charsmax( filename ), "%s/%s.rar",archive_dir, iArchiveName );
	//delete_file(filename);
	iArchive = fopen(filename, "wb");
	new CURL:curl = curl_easy_init();
	if(curl)
	{
		curl_easy_setopt(curl, CURLOPT_URL, iLink);
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, "write_archive");
		curl_easy_perform(curl, "complete_archive");
	}
}

public write_archive(const data[], const size, const nmemb)
{
	new real_size = size * nmemb;

	for(new i = 0; i < nmemb; i++)
	{
		fwrite(iArchive, data[i], BLOCK_BYTE);
	}

	return real_size

}

public complete_archive(CURL:curl, CURLcode:code) {

/*

	if (code == CURLE_OK)
	{
		static statusCode;
		curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, statusCode);
		if (statusCode >= 400)
		{
			server_print("[Error] HTTP Error: %d", statusCode);
		}
	}
	else
	{
		server_print("[Error] cURL Error: %d", code);
		curl_easy_cleanup(curl);
		curl = CURL:0;
	}
*/

	curl_easy_cleanup(curl)
	fclose(iArchive);
	if(code != CURLE_OK )
	{
	
		server_print("[Error] cURL Error: %s", code);
	}
	OnArchiveComplete();
}


public OnArchiveComplete()
{

	new filename[128];
	format( filename, charsmax( filename ), "%s.rar", iArchiveName );
	
	new RARArchive[128];
	format( RARArchive, charsmax( RARArchive ), "kz_downloader/archives/%s.rar", iArchiveName );
	AA_Unarchive(RARArchive);


	format( filename, charsmax( filename ), "%s/%s.rar",archive_dir, iArchiveName );
//	delete_file(filename);	

//	new szNavName[256];

//	format( szNavName, sizeof(szNavName), "%s", temp_dir, iArchiveName );
	//if(!dir_exists(szNavName))
	//{
	//	mkdir(szNavName);
	//	
	//}

	format( iDemoName, sizeof(iDemoName), "%s/%s.dem", temp_dir, iArchiveName );
	if ( !file_exists( iNavName ) )
	{
		#if defined DEV_DEBUG
		server_print( "%s ne exists" , iNavName);
		#endif
		iFile = fopen( iDemoName, "rb" );
		if ( iFile )
		{
			iParsedFile = fopen( iNavName, "w" );
			ReadHeaderX();
			/*fclose(iFile);
			fclose(iParsedFile);
			LoadParsedInfo( szNavName );*/
		}
	}else  {
		LoadParsedInfo( iNavName );
	}
}


public fnConvertTime( Float:time, convert_time[], len )
{
	new sTemp[24];
	new Float:fSeconds = time, iMinutes;

	iMinutes        = floatround( fSeconds / 60.0, floatround_floor );
	fSeconds        -= iMinutes * 60.0;
	new intpart     = floatround( fSeconds, floatround_floor );
	new Float:decpart   = (fSeconds - intpart) * 100.0;
	intpart         = floatround( decpart );

	formatex( sTemp, charsmax( sTemp ), "%02i%02.0f.%02d", iMinutes, fSeconds, intpart );


	formatex( convert_time, len, sTemp );
	#if defined DEV_DEBUG
//	server_print( "%f %s, %s",time, sTemp, convert_time);
	#endif
	return(PLUGIN_HANDLED);
}

public LoadParsedInfo(szNavName[])
{
	iFile = fopen( szNavName, "rb" );
	new Ent = engfunc( EngFunc_CreateNamedEntity , engfunc( EngFunc_AllocString,"info_target" ) );
	set_pev(Ent, pev_classname, "NavThink");
	set_pev(Ent, pev_nextthink, get_gametime() + 0.01 );
}

public ReadHeaderX()
{
	if ( IsValidDemoFile( iFile ) )
	{
		ReadHeader( iFile );
		new Ent = engfunc( EngFunc_CreateNamedEntity , engfunc( EngFunc_AllocString,"info_target" ) );
		set_pev(Ent, pev_classname, "DemThink");
		set_pev(Ent, pev_nextthink, get_gametime() + 0.01 );

	}else {
		server_print( "NOTVALID" );
	}
}

public bool:IsValidDemoFile( file )
{
	fseek( file, 0, SEEK_END );
	iDemo_header_size = ftell( file );


	if ( iDemo_header_size < HEADER_SIZE )
	{
		return(false);
	}

	fseek( file, 0, SEEK_SET );
	new signature[HEADER_SIGNATURE_CHECK_SIZE];


	fread_blocks( file, signature, sizeof(signature), BLOCK_CHAR );

	if ( !contain( "HLDEMO", signature ) )
	{
		return(false);
	}

	return(true);
}


public ReadHeader( file )
{
	fseek( file, HEADER_SIGNATURE_SIZE, SEEK_SET );

	fread( file, iDemoHeader[demoProtocol], BLOCK_INT );

	if ( iDemoHeader[demoProtocol] != 5 )
	{
	}

	fread( file, iDemoHeader[netProtocol], BLOCK_INT );

	if ( iDemoHeader[netProtocol] != 48 )
	{
	}

	fread_blocks( file, iDemoHeader[mapName], HEADER_MAPNAME_SIZE, BLOCK_CHAR );
	fread_blocks( file, iDemoHeader[gameDir], HEADER_GAMEDIR_SIZE, BLOCK_CHAR );

	fread( file, iDemoHeader[mapCRC], BLOCK_INT );
	fread( file, iDemoHeader[directoryOffset], BLOCK_INT );

	fseek( file, iDemoHeader[directoryOffset], SEEK_SET );

	new newPosition = ftell( file );

	if ( newPosition != iDemoHeader[directoryOffset] )
	{
		/*server_print( "kek :(" );*/
	}
	fread( file, iDemoEntry[dirEntryCount], BLOCK_INT );
	for ( new i = 0; i < iDemoEntry[dirEntryCount]; i++ )
	{
		fread( file, iDemoEntry[type], BLOCK_INT );
		fread_blocks( file, iDemoEntry[description], DIR_ENTRY_DESCRIPTION_SIZE, BLOCK_CHAR );
		fread( file, iDemoEntry[flags], BLOCK_INT );
		fread( file, iDemoEntry[CDTrack], BLOCK_INT );
		fread( file, iDemoEntry[trackTime], BLOCK_INT );
		fread( file, iDemoEntry[frameCount], BLOCK_INT );
		fread( file, iDemoEntry[offset], BLOCK_INT );
		fread( file, iDemoEntry[fileLength], BLOCK_INT );
	}

	fseek( file, iDemoEntry[offset], SEEK_SET );

/* server_print( "%d %d %s %s %d %d %d", iDemoHeader[demoProtocol], iDemoHeader[netProtocol], iDemoHeader[mapName], iDemoHeader[gameDir], iDemoHeader[mapCRC], iDemoHeader[directoryOffset], iDemoEntry[dirEntryCount] ); */
}

public ReadParsed( iEnt )
{
	if ( iFile )
	{
		new szLineData[512];
		static sExplodedLine[11][150];
		if ( !feof( iFile ) )
		{
			fseek(iFile, 0, SEEK_CUR);
			new iSeek = ftell(iFile);
			fseek(iFile, 0, SEEK_END);
			#if defined DEV_DEBUG
			new iFinish = ftell(iFile);
			server_print("%.2f%% NAV READED", float(iSeek)/float(iFinish)*100.0);
			#endif
			fseek(iFile, iSeek, SEEK_SET);

			/* read one line */
			fgets( iFile, szLineData, charsmax( szLineData ) );


			/*
			 * replace newlines with a null character to prevent headaches
			 * replace(szLineData, charsmax(szLineData), "^n", "")
			 */

			ExplodeString( sExplodedLine, 10, 50, szLineData, '|' );
			if ( equal( sExplodedLine[1], "ASD" ) )
			{
				new Keys        = str_to_num( sExplodedLine[2] );
				new Float:Angles[3];
				Angles[0]   = str_to_float( sExplodedLine[3] );
				Angles[1]   = str_to_float( sExplodedLine[4] );
				Angles[2]   = 0.0;
				new Float:Origin[3];
				Origin[0]   = str_to_float( sExplodedLine[5] );
				Origin[1]   = str_to_float( sExplodedLine[6] );
				Origin[2]   = str_to_float( sExplodedLine[7] );
				new Float:velocity[3]
				velocity[0] = str_to_float( sExplodedLine[8] );
				velocity[1] = str_to_float( sExplodedLine[9] );
				velocity[2] = 0.0;

			ArrayPushArray( fPlayerAngle, Angles );
			ArrayPushArray( fPlayerOrigin, Origin );
				ArrayPushArray( fPlayerVelo, velocity );
				ArrayPushCell( fPlayerKeys, Keys );
			}
			set_pev( iEnt, pev_nextthink, get_gametime()+0.0001 );
			return true;
		}
		else
		{
			return false;
		}
	}

	return false;
}
public ReadFrames( file )
{

	fseek(file, 0, SEEK_CUR);
	new iSeek = ftell(file);
	fseek(file, 0, SEEK_END);
	fseek(iFile, iSeek, SEEK_SET);
	#if defined DEV_DEBUG
	new iFinish = ftell(file);
	server_print("%.2f%% DEMO PARSED", float(iSeek)/float(iFinish)*100.0);
	#endif

	static sum;

	if ( !feof( file ) )
	{
		new FrameType = ReadFrameHeader( file );
		new breakme;
		/*
		 * server_print( "TOTAL: %d", FrameType );
		 * server_print( "LEL%d %d %d", FrameType, iDemoFrame[Timestamp], iDemoFrame[Number] );
		 */
		switch ( FrameType )
		{
			case 0:
			{
			}
			case 1:
			{
				new Float:Origin[3], Float:ViewAngles[3], Float:velocity[3], iAsd[1024];
				fseek( file, 4, SEEK_CUR );                             // read_object(demo, f.DemoInfo.timestamp);
				for ( new i = 0; i < 3; ++i )
					fseek( file, 4, SEEK_CUR );                     // read_object(demo, f.DemoInfo.RefParams.vieworg);
				for ( new i = 0; i < 3; ++i )
					fread( file, _:ViewAngles[i], BLOCK_INT );  // read_object(demo, f.DemoInfo.RefParams.viewangles);

				fseek( file, 64, SEEK_CUR );                            // пропуск до следующего участка.

				for ( new i = 0; i < 3; ++i )
					fread( file, _:velocity[i], BLOCK_INT );        // read_object(demo, f.DemoInfo.RefParams.simvel);
				for ( new i = 0; i < 3; ++i )
					fread( file, _:Origin[i], BLOCK_INT );          // read_object(demo, f.DemoInfo.RefParams.simorg);

				fseek( file, 124, SEEK_CUR );                       // пропуск до следующего участка.

				for ( new i = 0; i < 3; ++i )
					fseek( file, 4, SEEK_CUR );                     // read_object(demo, f.DemoInfo.UserCmd.viewangles);

				fseek( file, 4, SEEK_CUR );                     /* read_object(demo, f.ForwardMove); */
				fseek( file, 4, SEEK_CUR );                     /* read_object(demo, f.SideMove); */
				fseek( file, 4, SEEK_CUR );                     /* read_object(demo, f.UpmoveMove); */
				fseek( file, 2, SEEK_CUR );                     /* read_object(demo, f.lightlevel && f.align_2; */
				fread( file, iDemoEntry[ubuttons], BLOCK_SHORT );

				format( iAsd, charsmax( iAsd ), "%d|ASD|%d|%.4f|%.4f|%.3f|%.3f|%f|%.3f|%.3f|%.3f^n",sum, iDemoEntry[ubuttons], ViewAngles[0], ViewAngles[1], Origin[0],Origin[1],Origin[2], velocity[0], velocity[1], velocity[2] );
				fputs( iParsedFile, iAsd );
				fseek( file, 196, SEEK_CUR ); // static
				new length;
				fread( file, length, BLOCK_INT ); // static
				fseek( file, length, SEEK_CUR ); // static
			}
			case 2:
			{
			}
			case 3:
			{
				new ConsoleCmd[FRAME_CONSOLE_COMMAND_SIZE];
				fread_blocks( file, ConsoleCmd, FRAME_CONSOLE_COMMAND_SIZE, BLOCK_CHAR );
			}
			case 4:
			{
				sum++;
				for ( new i = 0; i < 3; ++i )                               // Бот чуть выше земли и pre будет показывать, как UP
					fseek( file, 4, SEEK_CUR );                             // write_object(o, f->origin[i]);
				for ( new i = 0; i < 3; ++i )                               // write_object(o, f->viewangles[i]);
					fseek( file, 4, SEEK_CUR );

				fseek( file, 4, SEEK_CUR );                             // write_object(o, f->weaponBits);
				fseek( file, 4, SEEK_CUR );                             // write_object(o, f->fov);
			}
			case 5:
			{
				breakme = 2;
			}
			case 6:
			{
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.flags); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.index); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.delay); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.flags); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.entityIndex); */
				for ( new i = 0; i < 3; ++i )
					fseek( file, 4, SEEK_CUR );     /* read_object(demo, f.EventArgs.origin[i]); */
				for ( new i = 0; i < 3; ++i )
					fseek( file, 4, SEEK_CUR );     /* read_object(demo, f.EventArgs.angles[i]); */
				for ( new i = 0; i < 3; ++i )
					fseek( file, 4, SEEK_CUR );     /* read_object(demo, f.EventArgs.velocity[i]); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.ducking); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.fparam1); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.fparam2); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.iparam1); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.iparam2); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.bparam1); */
				fseek( file, 4, SEEK_CUR );             /* read_object(demo, f.EventArgs.bparam2); */
			}
			case 7:
			{
				fseek( file, 8, SEEK_CUR );
			}
			case 8:
			{
				fseek( file, 4, SEEK_CUR );
				new length;
				fread( file, length, BLOCK_INT );
				new msg[128];
				fread_blocks( file, msg, length, BLOCK_CHAR );
				fseek( file, 16, SEEK_CUR );
			}
			case 9:
			{
				new length = 0;
				fread( file, length, BLOCK_INT );
				new buffer[4];
				fread_blocks( file, buffer, length, BLOCK_BYTE );
			}
			default:
			{
				breakme = 2;
			}
		}

		if(breakme == 2)
		{
			return true;
		}
	}

	return false;
}


public ReadFrameHeader( file )
{
	fread( file, iDemoFrame[Type], BLOCK_BYTE );
	fread( file, _:iDemoFrame[Timestamp], BLOCK_INT );
	fread( file, iDemoFrame[Number], BLOCK_INT );

	return(iDemoFrame[Type]);
}

public ExplodeString( p_szOutput[][], p_nMax, p_nSize, p_szInput[], p_szDelimiter )
{
	new nIdx    = 0, l = strlen( p_szInput );
	new nLen    = (1 + copyc( p_szOutput[nIdx], p_nSize, p_szInput, p_szDelimiter ) );
	while ( (nLen < l) && (++nIdx < p_nMax) )
		nLen += (1 + copyc( p_szOutput[nIdx], p_nSize, p_szInput[nLen], p_szDelimiter ) );
	return(nIdx);
}

public check_dir()
{
	new demoslist[32], file[64];
	get_localinfo( "amxx_datadir", demoslist, charsmax( demoslist ) );
	format( demoslist, charsmax( demoslist ), "%s/kz_wrbot", demoslist );
	new dirh = open_dir(demoslist, file, 63) 
	while(next_file(dirh, file, 63))
	{
		new left[128], right[128], g_right[32], g_left[32], texturl[128]
		strtok(file, left, 127, right, 127, '.') 
		strtok(right, g_left, 31, g_right, 31, '.') 
		formatex(texturl, charsmax(texturl), "%s/%s", demoslist, file) 

		if(equali(g_right, "dem") || equali(g_right, "nav") || equali(g_right, "rar") || equali(g_right, "zip")) 
		{
			delete_file(texturl)
		}
	}
}

public parsing_country(data[])
{
	new demoslist[128];
	if(equali(data, "xj"))
		format( demoslist, charsmax( demoslist ), "%s/demos.txt", archive_dir );
	else if(equali(data, "cc"))
		format( demoslist, charsmax( demoslist ), "%s/demoz.txt", archive_dir );

	#if defined DEV_DEBUG
	server_print( "Parsing XJ Demo List" );
	#endif
	new iDemosList  = fopen( demoslist, "rb" );
	new ExplodedString[7][128];
	new Line[128];
	new MapName[64];
	get_mapname( MapName, 63 );
	while ( !feof( iDemosList ) )
	{
		fgets( iDemosList, Line, charsmax( Line ) );
		ExplodeString( ExplodedString, 6, 127, Line, ' ' );
		new parsedmap[128];
		parsedmap = ExplodedString[0];
		format( parsedmap, charsmax( parsedmap ), "%s ", parsedmap );
		if ( containi( parsedmap, MapName ) == 0 )
		{
			g_Demos = true;
			break;
		}
	}
	if ( !g_Demos )
	{
		get_mapname( MapName, 63 );
		format( MapName, charsmax( MapName ), "%s[", MapName );
		fseek( iDemosList, 0, SEEK_SET );
		while ( !feof( iDemosList ) )
		{
			fgets( iDemosList, Line, charsmax( Line ) );
			ExplodeString( ExplodedString, 6, 127, Line, ' ' );
			if ( containi( ExplodedString[0], MapName ) == 0 )
			{
				g_Demos = true;
				break;
			}
		}
	}
	else
	{
		new FLAG[10]
		formatex(FLAG, charsmax(FLAG), "%s", ExplodedString[3]);
		trim(FLAG)
		if (equali(FLAG, "")) FLAG = "xz";
		if (equali(FLAG, "n-")) FLAG = "xz";

		formatex(url_sprite, charsmax(url_sprite), "sprites/wrbot/%s.spr", FLAG);
		formatex(url_sprite_xz, charsmax(url_sprite_xz), "sprites/wrbot/xz.spr");
		if(file_exists(url_sprite))
			precache_model(url_sprite)
		else if(file_exists(url_sprite_xz))
			precache_model(url_sprite_xz)
		else
			return
	}

	if ( !g_Demos && equali(data, "xj") )
		parsing_country("cc")
}


stock ham_give_weapon(id,weapon[])
{
	if(!equal(weapon,"weapon_",7))
		return 0

	new wEnt = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,weapon));

	if(!pev_valid(wEnt))
		return 0

	set_pev(wEnt,pev_spawnflags,SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn,wEnt)

	if(!ExecuteHamB(Ham_AddPlayerItem,id,wEnt))
	{
		if(pev_valid(wEnt)) set_pev(wEnt,pev_flags,pev(wEnt,pev_flags) | FL_KILLME);
		return 0
	}

	ExecuteHamB(Ham_Item_AttachToPlayer,wEnt,id)
	return 1
}

stock StringTimer(const Float:flRealTime, szOutPut[], const iSizeOutPut)
{
	static Float:flTime, iMinutes, iSeconds, iMiliSeconds, Float:iMili;
	new string[12]

	flTime = flRealTime;

	if(flTime < 0.0) flTime = 0.0;

	iMinutes = floatround(flTime / 60, floatround_floor);
	iSeconds = floatround(flTime - (iMinutes * 60), floatround_floor);
	iMili = floatfract(flRealTime)
	formatex(string, 11, "%.02f", iMili >= 0 ? iMili + 0.005 : iMili - 0.005);
	iMiliSeconds = floatround(str_to_float(string) * 100, floatround_floor);

	formatex(szOutPut, iSizeOutPut, "%02d:%02d.%02d", iMinutes, iSeconds, iMiliSeconds);
}
